// Poisson Blending on GPU
// http://cs.brown.edu/courses/csci1950-g/results/proj2/edwallac/

#pragma kernel MakeBorder
#pragma kernel PoissonBlending

Texture2D<float4> Source;
Texture2D<float4> Mask;
Texture2D<float4> Target;

RWTexture2D<float4> Result;
RWTexture2D<float> Border;


inline float3 solve(in float3 src, in float3 centerD, in uint2 tid)
{

	float3 c = (Border[tid].r > 0.5) ? Target[tid].rgb : Result[tid].rgb;
	c += src - Source[tid].rgb;
	return c;
}

[numthreads(16, 16, 1)]
void MakeBorder(uint2 tid : SV_DispatchThreadID)
{
	float n = Mask[tid].r;
	if (n < 0.5)
	{
		Border[tid] = 0.0;
		return;
	}

	uint2 right = tid + uint2(1, 0);
	uint2 left = tid + uint2(-1, 0);
	uint2 up = tid + uint2(0, 1);
	uint2 down = tid + uint2(0, -1);

	if (
		Mask[right].r < 0.5
		|| Mask[left].r < 0.5
		|| Mask[up].r < 0.5
		|| Mask[down].r < 0.5)
	{
		Border[tid] = 1.0;
	}
	else {
		Border[tid] = 0.0;
	}
}

[numthreads(16, 16, 1)]
void PoissonBlending(uint2 tid : SV_DispatchThreadID)
{
	float width, height;
	Result.GetDimensions(width, height);

	// Init with target
	Result[tid] = Target[tid];

	float mask = Mask[tid].x;
	// Filter edge case
	if (mask < 0.1
		|| tid.x == 0 || tid.y == 0
		|| tid.x >= (uint)(width - 1.0) || tid.y >= (uint)(height - 1.0))
	{
		// Outside of the mask area
		return;
	}

	float3 src = Source[tid].rgb;
	float3 dst = Target[tid].rgb;

	uint2 right = tid + uint2(1, 0);
	uint2 left = tid + uint2(-1, 0);
	uint2 up = tid + uint2(0, 1);
	uint2 down = tid + uint2(0, -1);

	for (int i = 0; i < 1000; i++)
	{
		float3 sum = float3(0.0, 0.0, 0.0);

		sum += solve(src, dst, right);
		sum += solve(src, dst, left);
		sum += solve(src, dst, up);
		sum += solve(src, dst, down);

		sum = clamp(sum * 0.25, float3(0, 0, 0), float3(1, 1, 1));
		Result[tid] = float4(sum, 1.0);

		//GroupMemoryBarrier();
		GroupMemoryBarrierWithGroupSync();
	}

}
