// Poisson Blending on GPU
// http://cs.brown.edu/courses/csci1950-g/results/proj2/edwallac/

#pragma kernel Init
#pragma kernel PoissonBlending

Texture2D<float4> Source;
Texture2D<float4> Mask;
Texture2D<float4> Target;
RWTexture2D<float4> Result;


inline float3 abs3(in float3 a, in float3 b)
{
	return float3(
		abs(a.r) > abs(b.r) ? a.r : b.r,
		abs(a.g) > abs(b.g) ? a.g : b.g,
		abs(a.b) > abs(b.b) ? a.b : b.b
		);
}

inline float3 solve(in float3 center, in float3 centerD, in uint2 tid)
{
	float3 gradSrc = center - Source[tid].rgb;
	return Result[tid].rgb + gradSrc;

	//float3 gradDst = centerD - Target[tid].rgb;
	//return Result[tid].rgb + gradSrc * 0.99 + gradDst * 0.01;
}

[numthreads(16, 16, 1)]
void Init(uint2 tid : SV_DispatchThreadID)
{
	Result[tid] = Target[tid];
}

[numthreads(16, 16, 1)]
void PoissonBlending(uint2 tid : SV_DispatchThreadID)
{
	float width, height;
	Result.GetDimensions(width, height);

	float mask = Mask[tid].x;
	// Filter edge case
	if (mask < 0.1
		|| tid.x == 0 || tid.y == 0
		|| tid.x >= (uint)(width - 1.0) || tid.y >= (uint)(height - 1.0))
	{
		// Outside of the mask area
		Result[tid] = Target[tid];
		return;
	}

	float3 src = Source[tid].rgb;
	float3 dst = Target[tid].rgb;

	for (int i = 0; i < 500; i++)
	{
		float3 sum = float3(0.0, 0.0, 0.0);
		sum += solve(src, dst, tid + uint2(1, 0));
		sum += solve(src, dst, tid + uint2(-1, 0));
		sum += solve(src, dst, tid + uint2(0, 1));
		sum += solve(src, dst, tid + uint2(0, -1));

		Result[tid] = float4(sum * 0.25, 1.0);

		GroupMemoryBarrierWithGroupSync();
	}

}
